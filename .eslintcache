[{"E:\\Projects\\Apps\\sketchy-reactjs\\src\\index.js":"1","E:\\Projects\\Apps\\sketchy-reactjs\\src\\App.js":"2","E:\\Projects\\Apps\\sketchy-reactjs\\src\\reportWebVitals.js":"3","E:\\Projects\\Apps\\sketchy-reactjs\\src\\components\\Canvas\\Canvas.js":"4","E:\\Projects\\Apps\\sketchy-reactjs\\src\\components\\ToolProvider.js":"5","E:\\Projects\\Apps\\sketchy-reactjs\\src\\components\\ToolBar\\ToolBar.js":"6"},{"size":517,"mtime":1612048347815,"results":"7","hashOfConfig":"8"},{"size":303,"mtime":1612130940518,"results":"9","hashOfConfig":"8"},{"size":375,"mtime":1612053451208,"results":"10","hashOfConfig":"8"},{"size":12031,"mtime":1612385316883,"results":"11","hashOfConfig":"8"},{"size":336,"mtime":1612201063454,"results":"12","hashOfConfig":"8"},{"size":2119,"mtime":1612130947061,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"bw5d4e",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"24"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"16"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"E:\\Projects\\Apps\\sketchy-reactjs\\src\\index.js",[],["30","31"],"E:\\Projects\\Apps\\sketchy-reactjs\\src\\App.js",[],"E:\\Projects\\Apps\\sketchy-reactjs\\src\\reportWebVitals.js",[],"E:\\Projects\\Apps\\sketchy-reactjs\\src\\components\\Canvas\\Canvas.js",["32","33","34","35","36"],"import React, { useRef, useEffect, useLayoutEffect, useState, useContext } from 'react'\r\nimport { ToolContext } from '../ToolProvider'\r\nimport rough from 'roughjs/bundled/rough.esm'\r\n\r\nconst useHistory = (initialState) => {\r\n    // Undo / Redo\r\n}\r\n\r\nexport default function Canvas() {\r\n    const [tool, setTool]         = useContext(ToolContext)\r\n    const [action, setAction]     = useState(null)\r\n    const [selected, setSelected] = useState(null)\r\n    const [elements, setElements] = useState([])\r\n\r\n    const canvasRef = useRef(null)\r\n    const roughCanvasRef = useRef(null)\r\n    const generator = rough.generator()\r\n\r\n    useLayoutEffect(() => {\r\n        const canvas  = canvasRef.current\r\n        canvas.width = window.innerWidth * 2\r\n        canvas.height = window.innerHeight * 2\r\n        canvas.style.width = `${window.innerWidth}px`\r\n        canvas.style.height = `${window.innerHeight}px`\r\n\r\n        roughCanvasRef.current = rough.canvas(canvas)\r\n\r\n        const context = canvas.getContext('2d')\r\n        context.scale(2, 2)\r\n        context.clearRect(0, 0, canvas.width, canvas.height)\r\n        elements.forEach( ({element}) => roughCanvasRef.current.draw(element) )\r\n    }, [elements])\r\n    \r\n    /*useLayoutEffect(() => {\r\n        console.log('called')\r\n        if(selected) {\r\n            removeResizeHandler()            \r\n            //addResizeHandler(selected)\r\n        } else {            \r\n            removeResizeHandler()\r\n        }\r\n        \r\n    }, [selected])*/\r\n\r\n    const handleMouseUp = () => {\r\n        if(action === 'drawing' || action === 'resizing') {\r\n            const index = elements.length - 1\r\n            const { x1, y1, x2, y2 } = getAdjustedCoordinates(elements[index])\r\n            updateElement(index, tool, { x1, y1, x2, y2 })\r\n        }\r\n\r\n        setAction('none')       \r\n    }\r\n\r\n    const handleMouseDown = (event) => {\r\n        const {clientX, clientY} = event        \r\n\r\n        if(tool === 'selection') {            \r\n            const element = getElementAtPosition(clientX, clientY)\r\n            \r\n            if(element) {\r\n                const { x1, y1, x2, y2 } = element\r\n\r\n                if(selected && selected.id === element.id) {\r\n                    const width = x2 - x1\r\n                    const height = y2 - y1\r\n                    setSelected({...element, offsetX: clientX - x1, offsetY: clientY - y1, width, height })\r\n                    setElements(prevState => prevState)\r\n                    setAction('moving')                    \r\n                } else {\r\n                    removeResizeHandler()\r\n\r\n                    if(element.position !== 'empty' && !selected) {\r\n                        setSelected(element)\r\n                        addResizeHandler(element)\r\n                        event.target.style.cursor = element ? setCursor(element.position) : 'default'\r\n                    }\r\n                }             \r\n            } else {\r\n                setSelected(null)\r\n                removeResizeHandler()\r\n            }\r\n        } else {\r\n            selected && removeResizeHandler()\r\n            const id = elements.length\r\n            const coords = { x1: clientX, y1: clientY, x2: clientX, y2: clientY }\r\n            const element = createElement(id, tool, coords)\r\n            setElements(prevState => [...prevState, element])            \r\n            setAction('drawing')            \r\n        }\r\n    }\r\n\r\n    const handleMouseMove = (event) => {\r\n        const { clientX, clientY } = event\r\n\r\n        if(tool === 'selection' && selected) {\r\n            const element = getElementAtPosition(clientX, clientY)\r\n            event.target.style.cursor = element ? setCursor(element.position) : 'default'\r\n        }\r\n\r\n        if(action === 'drawing') {\r\n            const index = elements.length - 1\r\n            const elementToUpdate = elements[index]\r\n            const {x1, y1} = elementToUpdate            \r\n            const coords = { x1, y1, x2: clientX, y2: clientY }\r\n            updateElement(index, tool, coords)\r\n        } else if(action === 'moving') {\r\n            const { id, offsetX, offsetY, width, height } = selected           \r\n            const x = clientX - offsetX\r\n            const y = clientY - offsetY\r\n            updateElement(id, selected.type, { x1: x, y1: y, x2: x + width, y2: y + height })\r\n        }\r\n    }\r\n\r\n    const createElement = (id, type, coords, lockRatio = false) => {\r\n        let { x1, y1, x2, y2 } = coords\r\n        let element\r\n        const options = {\r\n            fill: 'red'\r\n        }\r\n\r\n        switch (type) {\r\n            case 'line':\r\n                element = generator.line(x1, y1, x2, y2, options)\r\n                break\r\n            case 'rectangle':\r\n                element = lockRatio\r\n                    ? generator.rectangle(x1, y1, x2 - x1, x2 - x1, options)\r\n                    : generator.rectangle(x1, y1, x2 - x1, y2 - y1, options) \r\n                break\r\n            case 'ellipse':\r\n                element = lockRatio \r\n                    ? generator.ellipse((x1 + x2) / 2, (y1 + y2) / 2, x2 - x1, x2 - x1, options)\r\n                    : generator.ellipse((x1 + x2) / 2, (y1 + y2) / 2, x2 - x1, y2 - y1, options)\r\n                break;\r\n            case 'triangle':\r\n                element = lockRatio\r\n                    ? generator.path(`M ${x1},${y2} L ${x2},${y2} L ${(x2 - x1) / 2 + x1},${(x1 - x2) * Math.sqrt(3) / 2 + y2} L ${x1},${y2} Z`, options)\r\n                    : generator.path(`M ${x1},${y2} L ${x2},${y2} L ${(x2 - x1) / 2 + x1},${(y2 - y1) / 2 + y1} L ${x1},${y2} Z`, options)                    \r\n                break\r\n            case 'arrow':\r\n                const radians = 0.4\r\n                const [ diffX, diffY ] = [ x1 - x2, y1 - y2 ]\r\n                const newX = ( diffX * Math.cos(radians) + diffY * Math.sin(radians) ) / 10 + x2\r\n                const newY = ( -diffX * Math.sin(radians) + diffY * Math.cos(radians) ) / 10 + y2\r\n                const newX2 = ( diffX * Math.cos(radians) - diffY * Math.sin(radians) ) / 10 + x2\r\n                const newY2 = ( diffX * Math.sin(radians) + diffY * Math.cos(radians) ) / 10 + y2\r\n\r\n                element = generator.path(`M ${x1},${y1} L ${x2},${y2} L ${newX},${newY} M ${x2},${y2} L ${newX2},${newY2} Z`)\r\n                break\r\n            case 'outline':\r\n                const offset = 6\r\n\r\n                element = generator.rectangle(x1 - offset, y1 - offset, x2 - x1 + 2 * offset, y2 - y1 + 2 * offset, {\r\n                    roughness: 0.5,\r\n                    stroke: 'grey',\r\n                    strokeWidth: 2,\r\n                    strokeLineDash: [5, 10]\r\n                })\r\n                break\r\n            default:\r\n                element = generator.line(x1, y1, x2, y2, options)\r\n                break\r\n        }\r\n\r\n        return { id, type, x1, y1, x2, y2, element }\r\n    }\r\n\r\n    const removeElement = (id, length = 1) => {\r\n        const newElements = [...elements]\r\n        newElements.splice(id, length)\r\n        setElements(newElements)\r\n    }\r\n\r\n    const updateElement = (id, type, coords) => {        \r\n        const updatedElement = createElement(id, type, coords)\r\n        const newElements = [...elements]\r\n        newElements[id] = updatedElement\r\n\r\n        if(selected && tool === 'selection') {\r\n            const { x1, y1 } = coords\r\n            const outlineElement = createElement(elements.length - 2, 'outline', coords)\r\n            const resizer = createElement(elements.length - 1, 'outline', { x1: x1 - 2, y1: y1 - 2, x2: x1 + 2, y2: y1 + 2 })\r\n            newElements[elements.length - 2] = outlineElement\r\n            newElements[elements.length - 1] = resizer\r\n        }\r\n        \r\n        setElements(newElements)        \r\n    }\r\n\r\n    const getDistance = (a, b) => Math.sqrt( Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2) )\r\n\r\n    const getElementAtPosition = (x, y) => {\r\n        return elements\r\n            .map(element => ({ ...element, position: getPositionWithinElement(x, y, element) }))\r\n            .find(element => element.position !== null)\r\n    }\r\n\r\n    const getAdjustedCoordinates = (element) => {\r\n        const { type, x1, y1, x2, y2 } = element\r\n        const minX = Math.min(x1, x2)\r\n        const maxX = Math.max(x1, x2)\r\n        const minY = Math.min(y1, y2)\r\n        const maxY = Math.max(y1, y2)\r\n\r\n        switch (type) {\r\n            case 'rectangle':\r\n            case 'ellipse':\r\n                return { x1: minX, y1: minY, x2: maxX, y2: maxY }            \r\n            case 'triangle':\r\n                return { x1, y1, x2, y2 } // To Fix\r\n            case 'line':\r\n                const coords = (x1 < x2 || (x1 === x2 && y1 < y2)) ? { x1, y1, x2, y2 } : { x1: x2, y1: y2, x2: x1, y2: y1 }\r\n                return coords\r\n            case 'arrow':\r\n                return { x1, y1, x2, y2 } // To Fix\r\n            default:\r\n                return { x1, y1, x2, y2 }\r\n        }\r\n    }\r\n\r\n    const getPositionWithinElement = (x, y, element) => {\r\n        const { type, x1, y1, x2, y2 } = element\r\n        const middleX = (x2 - x1) / 2\r\n        const middleY = (y2 - y1) / 2\r\n        const offset = 6\r\n\r\n        if(type === 'rectangle' || type === 'ellipse' || type === 'triangle') {\r\n            if(Math.abs(x - offset) > x1 && Math.abs(x + offset) < x2 && Math.abs(y - offset) > y1 && Math.abs(y + offset) < y2) {\r\n                if(element.element.options.fill) {\r\n                    return 'inside'\r\n                } else {\r\n                    return 'empty'\r\n                }            \r\n            } else {\r\n                const topLeft     = nearPoint(x, y, x1, y1, offset, 'topLeft')\r\n                const topRight    = nearPoint(x, y, x2, y1, offset, 'topRight')\r\n                const bottomLeft  = nearPoint(x, y, x1, y2, offset, 'bottomLeft')\r\n                const bottomRight = nearPoint(x, y, x2, y2, offset, 'bottomRight')\r\n                const edge = \r\n                    Math.abs(x - x1) < offset || \r\n                    Math.abs(x - x2) < offset || \r\n                    Math.abs(y - y1) < offset ||\r\n                    Math.abs(y - y2) < offset ? 'edge' : null\r\n\r\n                return topLeft || topRight || bottomLeft || bottomRight || edge\r\n            }\r\n        } else {\r\n            const a = { x: x1, y: y1 }\r\n            const b = { x: x2, y: y2 }\r\n            const c = { x, y }\r\n            const distance = getDistance(a, b) - ( getDistance(a, c) + getDistance(b, c) )\r\n            const start  = nearPoint(x, y, x1, y1, offset, 'start')\r\n            const end    = nearPoint(x, y, x2, y2, offset, 'end')\r\n            const inside = Math.abs(distance) < offset ? 'inside' : null\r\n\r\n            return start || end || inside\r\n        }\r\n    }\r\n\r\n    const nearPoint = (x, y, x1, y1, offset, name) => Math.abs(x - x1) < offset && Math.abs(y - y1) < offset ? name : null\r\n\r\n    const addResizeHandler = (element) => {\r\n        const { x1, y1, x2, y2 } = element\r\n        const outline = createElement(elements.length, 'outline', { x1, y1, x2, y2 })\r\n        setElements(prevState => [...prevState, outline])\r\n\r\n        const resizer = createElement(elements.length + 1, 'outline', { x1: x1 - 4, y1: y1 - 4, x2: x1 - 2, y2: y1 - 2 })\r\n        setElements(prevState => [...prevState, resizer])\r\n    }\r\n\r\n    const removeResizeHandler = () => {\r\n        const outline = elements.find(element => element.type === 'outline')\r\n    \r\n        if(outline) {\r\n            removeElement(outline.id, 2)\r\n            setSelected(null)\r\n            setAction(null)            \r\n        }\r\n    }\r\n\r\n    const setCursor = (position) => {\r\n        switch (position) {\r\n            case 'inside':\r\n                return 'move'\r\n        \r\n            default:\r\n                break\r\n        }\r\n    }\r\n\r\n    return (\r\n        <canvas\r\n            ref={canvasRef}\r\n            onMouseDown={handleMouseDown}\r\n            onMouseUp={handleMouseUp}\r\n            onMouseMove={handleMouseMove}\r\n        >Your browser doesn't support canvas\r\n        </canvas>\r\n    )\r\n} ",["37","38"],"E:\\Projects\\Apps\\sketchy-reactjs\\src\\components\\ToolProvider.js",["39"],"import React, { useState } from 'react'\r\n\r\nconst initialState = 'rectangle'\r\n\r\nexport const ToolContext = React.createContext()\r\n\r\nexport default ({ children }) => {\r\n    const [tool, setTool] = useState(initialState)\r\n\r\n    return (\r\n        <ToolContext.Provider value={[tool, setTool]}>{ children }</ToolContext.Provider>\r\n    )\r\n}\r\n","E:\\Projects\\Apps\\sketchy-reactjs\\src\\components\\ToolBar\\ToolBar.js",[],{"ruleId":"40","replacedBy":"41"},{"ruleId":"42","replacedBy":"43"},{"ruleId":"44","severity":1,"message":"45","line":1,"column":25,"nodeType":"46","messageId":"47","endLine":1,"endColumn":34},{"ruleId":"44","severity":1,"message":"48","line":5,"column":7,"nodeType":"46","messageId":"47","endLine":5,"endColumn":17},{"ruleId":"44","severity":1,"message":"49","line":10,"column":18,"nodeType":"46","messageId":"47","endLine":10,"endColumn":25},{"ruleId":"44","severity":1,"message":"50","line":224,"column":15,"nodeType":"46","messageId":"47","endLine":224,"endColumn":22},{"ruleId":"44","severity":1,"message":"51","line":225,"column":15,"nodeType":"46","messageId":"47","endLine":225,"endColumn":22},{"ruleId":"40","replacedBy":"52"},{"ruleId":"42","replacedBy":"53"},{"ruleId":"54","severity":1,"message":"55","line":7,"column":1,"nodeType":"56","endLine":13,"endColumn":2},"no-native-reassign",["57"],"no-negated-in-lhs",["58"],"no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useHistory' is assigned a value but never used.","'setTool' is assigned a value but never used.","'middleX' is assigned a value but never used.","'middleY' is assigned a value but never used.",["57"],["58"],"import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]